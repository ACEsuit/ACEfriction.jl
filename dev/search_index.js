var documenterSearchIndex = {"docs":
[{"location":"data-import-export/#Friction-Data","page":"Friction Data","title":"Friction Data","text":"","category":"section"},{"location":"data-import-export/","page":"Friction Data","title":"Friction Data","text":"To train a friction tensor model in ACEfriciton.jl, friction data  D = (R_iGamma_i)_i=1^N_rm obs comprised of atomic configurations, R_i, and a friction tensors, Gamma_i is required. ","category":"page"},{"location":"data-import-export/","page":"Friction Data","title":"Friction Data","text":"ACEfriction.jl implements the structure FrictionData to store and manipulate single observations (R_iGamma_i) in the pre-training phase: ","category":"page"},{"location":"data-import-export/","page":"Friction Data","title":"Friction Data","text":"struct FrictionData\n    atoms\n    friction_tensor\n    friction_indices\nend","category":"page"},{"location":"data-import-export/","page":"Friction Data","title":"Friction Data","text":"where","category":"page"},{"location":"data-import-export/","page":"Friction Data","title":"Friction Data","text":"atoms – stores data of the atomic configuration ans is assumed to be of type JuLIP.Atoms,\nfriction_tensor – stores data on the friction tensor and is assumed to be of typeSparseMatrix{SMatrix{3, 3, T, 9}}, where T<:Float and Ti<:Int. That is, the friction tensor is stored in the form of sparse matrices with 3 times 3-matrix valued block entries,","category":"page"},{"location":"data-import-export/","page":"Friction Data","title":"Friction Data","text":"-friction_indices –  is a one-dimensional integer array, which contains all atom indices for which the friction tensor is defined.","category":"page"},{"location":"data-import-export/#Importing-and-Exporting-Friction-Data","page":"Friction Data","title":"Importing & Exporting Friction Data","text":"","category":"section"},{"location":"data-import-export/","page":"Friction Data","title":"Friction Data","text":"ACEfriction.DataUtils implements the function save_h5fdata(rdata::Vector{FrictionData}, filename::String) to save arrays of friction data to a custom costum formatted hdf5 file, as well as the function load_h5fdata(filename::String) to load friction data from such costum formatted hdf5 files.","category":"page"},{"location":"data-import-export/#Custom-HDF5-File-Format-for-Friction-Data","page":"Friction Data","title":"Custom HDF5 File Format for Friction Data","text":"","category":"section"},{"location":"data-import-export/","page":"Friction Data","title":"Friction Data","text":"The hierachical structure of such hdf5 files is as follows:","category":"page"},{"location":"data-import-export/","page":"Friction Data","title":"Friction Data","text":"Each observation (R_iGamma_i) is saved in a separate group in named by respective index i, i.e., we have the following groups on root level of the hdf5 file:","category":"page"},{"location":"data-import-export/","page":"Friction Data","title":"Friction Data","text":"├─ 📂 1   \n├─ 📂 2  \n├─ 📂 3   \n│  :   \n├─ 📂 N_obs   ","category":"page"},{"location":"data-import-export/","page":"Friction Data","title":"Friction Data","text":"Within each of these groups, the data of the respective  atomic configuration R_i and friction tensor Gamma_i are saved in the subgroups atoms and friction_tensor, respectively: ","category":"page"},{"location":"data-import-export/","page":"Friction Data","title":"Friction Data","text":"├─ 📂 i                        # Index of data point \n   ├─ 📂 atoms                 # Atom configuration data\n   │  ├─ 🔢 atypes\n   │  ├─ 🔢 cell \n   │  │  └─ 🏷️ column_major \n   │  ├─ 🔢 pbc\n   │  └─ 🔢 positions\n   │     └─ 🏷️ column_major\n   └─ 📂 friction_tensor       # Friction tensor data\n      ├─ 🔢 ft_I               \n      ├─ 🔢 ft_J\n      ├─ 🔢 ft_mask\n      └─ 🔢 ft_val, \n         └─ 🏷️ column_major","category":"page"},{"location":"data-import-export/","page":"Friction Data","title":"Friction Data","text":"Datasets in the group atoms store the equivalent information provided by the attributes  positions, numbers, cell, and pbc of atoms objects, i.e.,  an atomic configuration of N atoms is described by the following datasets contained in the group atoms:","category":"page"},{"location":"data-import-export/","page":"Friction Data","title":"Friction Data","text":"atypes – A one-dimensional Integer dataset of length N. The ith entry corresponds to the atomic element number of the ith atom in the configuration. (Note: types corresponds to the atoms attribute numbers in the ase.)\ncell – A two-dimensional Float64 dataset of size 3 x 3. \npbc – A one-dimensional Integer array of length 3 indicating the periodicity properties of the xyz dimension, e.g., pbc = [1,0,0] describes periodic boundary conditions in x dimension and non-periodic boundary conditions in the y and z dimensions. \npositions – A two-dimensional Float64 dataset of size n N x 3. The ith column corresponds to the position of the ith atom in the configuration ","category":"page"},{"location":"data-import-export/","page":"Friction Data","title":"Friction Data","text":"Datasets in the group friction_tensor store the friction tensor as a N x N sparse matrix with 3x3 valued block entries,  i.e., a friction tensor with m non-zero 3x3 blocks is stored","category":"page"},{"location":"data-import-export/","page":"Friction Data","title":"Friction Data","text":"ft_I – A one-dimensional Integer dataset of length m specifying the column indices of non-zero block entries of the friction tensor.\nft_J – A one-dimensional Integer dataset of length m specifying the row indices of non-zero block entries of the friction tensor.\nft_val – A three-dimensional Float64 dataset of size m x 3 x 3 specifying the values of the non-zero 3 x 3 block entries of  the friction tensor. For example, the 3 x 3 array ft_val[k,:,:] corresponds to the 3 x 3 block entry of the friction tensor with column index ft_I[k], and row index ft_J[k]. \nft_mask – A one-dimensional Integer dataset/list containg the indices of atoms for which friction information is provided. ","category":"page"},{"location":"data-import-export/","page":"Friction Data","title":"Friction Data","text":"note: Note\nAll two or three-dimensional datasets in the groups atoms have an additional attribute column_major. If the hdf5 file is created in a language that stores matrices in column-major form (e.g., julia), this attribute must be set to 1 (True). If the hdf5 file is created in a language that stores matrices in column-major form (e.g., python), this attribute must be set to 0 (False).","category":"page"},{"location":"fitting-mbdpd/#Fitting-a-Friction-Tensor-for-Simulation-of-(Multi-Body)-Dissipative-Particle-Dynamics","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Friction Tensor for Simulation of (Multi-Body) Dissipative Particle Dynamics","text":"","category":"section"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"In this workflow example we demonstrate how ACEfriction.jl can be used to fit a momentum-conserving friction tensor as used in Dissipative Particle Dynamics. ","category":"page"},{"location":"fitting-mbdpd/#Background-on-Dissipative-Particle-Dynamics","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Background on Dissipative Particle Dynamics","text":"","category":"section"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"Dissipative particle dynamics can be considered as a special version of the Langevin equation @ref, where the friction tensor Gamma is such that the total momentum is conserved, i.e.","category":"page"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"fracddtsum_i p_i(t) = bf 0","category":"page"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"In order for this to be the case, the friction tensor must satisfy the constraint","category":"page"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"sum_iGamma_ij = bf 0 text for every  j=1dots N_rm at","category":"page"},{"location":"fitting-mbdpd/#Momentum-conserving-Friction-Models-in-ACEfriction.jl","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Momentum-conserving Friction Models in ACEfriction.jl","text":"","category":"section"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"ACEfriction.jl provides utility functions for the construction of momentum-conserving friction models. Namely, the function mbdpd_matrixmodel yields a pair-wise coupled matrix model with additional symmetries such that resulting friction model satisfies the above constraints. For example, ","category":"page"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"m_cov = mbdpd_matrixmodel(EuclideanVector(), [:X], [:X];\n    maxorder=1, \n    maxdeg=5,    \n    rcutbond = 5.0, \n    rcutenv = 5.0,\n    zcutenv = 5.0,\n    n_rep = 1, \n    )\nfm= FrictionModel((m_cov=m_cov,)); ","category":"page"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"results in a momentum-conserving friction model with vector-equivariant blocks in the diffusion matrix. Here, the model is specified for the artifical atom element type :X.","category":"page"},{"location":"fitting-mbdpd/#Fit-Friction-Model-to-Synthetic-DPD-Friction-Data","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fit Friction Model to Synthetic DPD Friction Data","text":"","category":"section"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"The following code loads training and test data comprised of particle configurations and corresponding friction tensors:","category":"page"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"rdata_train = ACEfriction.DataUtils.load_h5fdata(\"./examples/data/dpd-train-x.h5\"); \nrdata_test = ACEfriction.DataUtils.load_h5fdata(\"./examples/data/dpd-train-x.h5\"); \n\nfdata = Dict(\"train\" => rdata_train, \n            \"test\"=> rdata_test);\n(n_train, n_test) = length(fdata[\"train\"]), length(fdata[\"test\"])","category":"page"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"Here the training data is contains friction tensors of 50 configurations each comprised of 64 particles, and the test data contains friction tensors of 10 configurations each comprised of 216 particles. The underlying friction tensors were synthetically generated using the following simple friction model, which is a smooth version of the standard heuristic DPD friction models commonly used in simulations: ","category":"page"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"Gamma_ij( (bf r_kz_k )_k=1^N_rm at) = begincases\ngamma(r_ij) hatbf r_ij otimes hatbf r_ji i neq j \n-sum_k neq i Gamma_ki i = j\nendcases","category":"page"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"where bf r_ij = bf r_j - bf r_i,  r_ij = bf r_ij_2, hatbf r_ij = bf r_ijr_ij, and","category":"page"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"gamma(r) = w exp left (-frac11-(rr_rm cut)^2 right ) ","category":"page"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"with weight w=50 and cutoff distance r_rm cut=50.","category":"page"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"To fit the model we execute exactly the same steps as in the previous example:","category":"page"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"ffm = FluxFrictionModel(params(fm;format=:matrix, joinsites=true))\nflux_data = Dict( \"train\"=> flux_assemble(fdata[\"train\"], fm, ffm),\n                  \"test\"=> flux_assemble(fdata[\"test\"], fm, ffm));\n\n\nloss_traj = Dict(\"train\"=>Float64[], \"test\" => Float64[])\nepoch = 0\nbatchsize = 10\nnepochs = 100\nopt = Flux.setup(Adam(1E-2, (0.99, 0.999)),ffm)\ndloader = DataLoader(flux_data[\"train\"], batchsize=batchsize, shuffle=true)\n\nfor _ in 1:nepochs\n    epoch+=1\n    @time for d in dloader\n        ∂L∂m = Flux.gradient(weighted_l2_loss,ffm, d)[1]\n        Flux.update!(opt,ffm, ∂L∂m)       # method for \"explicit\" gradient\n    end\n    for tt in [\"test\",\"train\"]\n        push!(loss_traj[tt], weighted_l2_loss(ffm,flux_data[tt]))\n    end\n    println(\"Epoch: $epoch, Abs avg Training Loss: $(loss_traj[\"train\"][end]/n_train)), Test Loss: $(loss_traj[\"test\"][end]/n_test))\")\nend","category":"page"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"After training for 2000 epochs, the resulting model is almost a perfect fit:","category":"page"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"(Image: True vs fitted entries of the friction tensor)             True vs fitted entries of the friction tensor.","category":"page"},{"location":"fitting-mbdpd/#Multi-Body-Dissipative-Particle-Dynamics","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Multi-Body Dissipative Particle Dynamics","text":"","category":"section"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"By specifying maxorder=1 in the above construction of the friction model, we restrict the underlying ACE-basis to only incorporate pair-wise interactions. This is fine for the here considered sythentic data as the underlying toy model is in fact based on only pair-wise interactions. However, in more complex systems  the random force and the dissipative force may not decompose to pairwise interactions. To incorporate higher body-order interactions in the friction model, say interactions up to body order 4, we can change the underlying ACE-basis expansion to incorporate correlation terms up to order 3 by setting maxorder=3. ","category":"page"},{"location":"function-manual/ACEfriction.MatrixModels/","page":"ACEfriction.MatrixModels","title":"ACEfriction.MatrixModels","text":"CurrentModule = ACEfriction.MatrixModels","category":"page"},{"location":"function-manual/ACEfriction.MatrixModels/","page":"ACEfriction.MatrixModels","title":"ACEfriction.MatrixModels","text":"RWCMatrixModel","category":"page"},{"location":"function-manual/ACEfriction.MatrixModels/#ACEfriction.MatrixModels.RWCMatrixModel","page":"ACEfriction.MatrixModels","title":"ACEfriction.MatrixModels.RWCMatrixModel","text":"function RWCMatrixModel(property, species_friction, species_env; \n    maxorder=2, \n    maxdeg=5,  \n    rcut = 5.0, \n    n_rep = 1, \n    species_substrat=[]\n)\n\nCreates a matrix model with row-wise coupling. By default, this model evaluates blocks Sigma_ij as a function of a spherical pair environment centered at the atom i.\n\nArguments:\n\nproperty – the equivariance symmetry wrt SO(3) of matrix blocks. Can be of type  Invariant, EuclideanVector, or EuclideanMatrix.\nspecies_friction – a list of chemical element types. Atoms of these lement types \"feel\" friction, i.e., only for atoms of these element types the  matrix model is evaluated, i.e., matrix blocks Sigma_ij are evaluated only if the element types of atoms i and j are contained in species_friction.  \nspecies_env – a list of all chemical element types that affect the evaluation of the friction tensor, i.e., blocks Sigma_ij of friction-feeling atoms i,j are functions of exactly the atoms within the pair environemnt (i,j) whose element type is listed in species_env.\n\nOptional arguments:\n\nmaxorder – the maximum correlaton order of the ACE-basis. A correlation order of n is equivalent to n+1-body interactions.\nmaxdeg – the maximum degree of the polynomial basis functions.\nrcut – cutoff radius of the spherical pair environment.\nn_rep – the number of matrix blocks evaluated per atom pair.\nspecies_substrat – a list of chemical element types. At least one atom of such element types must be within the pair-environemt of two friction-feeling atoms i,j in order for the matrix-block Sigma_ij to be non-zero.\n\n\n\n\n\n","category":"type"},{"location":"function-manual/ACEfriction.MatrixModels/","page":"ACEfriction.MatrixModels","title":"ACEfriction.MatrixModels","text":"PWCMatrixModel","category":"page"},{"location":"function-manual/ACEfriction.MatrixModels/#ACEfriction.MatrixModels.PWCMatrixModel","page":"ACEfriction.MatrixModels","title":"ACEfriction.MatrixModels.PWCMatrixModel","text":"PWCMatrixModel(property, species_friction, species_env;\nmaxorder=2, \nmaxdeg=5, \nrcut= 5.0,\nn_rep = 1, \nspecies_substrat=[]\n)\n\nCreates a matrix model with pair-wise coupling. In order to allow for good approximation of general friction tensors, this model should be combined with a matrix model of type OnsiteOnlyMatrixModel.\n\nBy default, this model evaluates blocks Sigma_ij as a function of a spherical pair environment centered at the atom i.\n\nArguments:\n\nproperty – the equivariance symmetry wrt SO(3) of matrix blocks. Can be of type  Invariant, EuclideanVector, or EuclideanMatrix.\nspecies_friction – a list of chemical element types. Atoms of these lement types \"feel\" friction, i.e., only for atoms of these element types the  matrix model is evaluated, i.e., matrix blocks Sigma_ij are evaluated only if the element types of atoms i and j are contained in species_friction.  \nspecies_env – a list of all chemical element types that affect the evaluation of the friction tensor, i.e., blocks Sigma_ij of friction-feeling atoms i,j are functions of exactly the atoms within the pair environemnt (i,j) whose element type is listed in species_env.\n\nOptional arguments:\n\nmaxorder – the maximum correlaton order of the ACE-basis. A correlation order of n is equivalent to n+1-body interactions.\nmaxdeg – the maximum degree of the polynomial basis functions.\nrcutbond, rcutenv, zcutenv – Parameters of the ellipsoid-shaped pair environments. rcutbond is the cutoff distance for the distance between the two pairs, zcutenv is the length of the axis (typically this will be the major axis) of the elipsoid aligned with the displacement of atoms i,j, and rcutenv is the length of the axis perpendicular to the displacement of atoms i,j.\nn_rep – the number of matrix blocks evaluated per atom pair.\nspecies_substrat – a list of chemical element types. At least one atom of such element types must be within the pair-environemt of two friction-feeling atoms i,j in order for the matrix-block Sigma_ij to be non-zero.\n\n\n\n\n\n","category":"type"},{"location":"function-manual/ACEfriction.MatrixModels/","page":"ACEfriction.MatrixModels","title":"ACEfriction.MatrixModels","text":"OnsiteOnlyMatrixModel","category":"page"},{"location":"function-manual/ACEfriction.MatrixModels/#ACEfriction.MatrixModels.OnsiteOnlyMatrixModel","page":"ACEfriction.MatrixModels","title":"ACEfriction.MatrixModels.OnsiteOnlyMatrixModel","text":"function OnsiteOnlyMatrixModel(property, species_friction, species_env; \n    maxorder=2, \n    maxdeg=5,  \n    rcut = 5.0, \n    n_rep = 1, \n    species_substrat=[]\n)\n\nCreates a matrix model that evaluates to a block-diagonal matrix. The resulting friction tensor is of the form of a block-diagonal matrix with 3x3 matrix blocks.\n\nArguments:\n\nproperty – the equivariance symmetry wrt SO(3) of matrix blocks. Can be of type  Invariant, EuclideanVector, or EuclideanMatrix.\nspecies_friction – a list of chemical element types. Atoms of these lement types \"feel\" friction, i.e., only for atoms of these element types the  matrix model is evaluated, i.e., matrix blocks Sigma_ij are evaluated only if the element types of atoms i and j are contained in species_friction.  \nspecies_env – a list of all chemical element types that affect the evaluation of the friction tensor, i.e., blocks Sigma_ij of friction-feeling atoms i,j are functions of exactly the atoms within the pair environemnt (i,j) whose element type is listed in species_env.\n\nOptional arguments:\n\nmaxorder – the maximum correlaton order of the ACE-basis. A correlation order of n is equivalent to n+1-body interactions.\nmaxdeg – the maximum degree of the polynomial basis functions.\nrcut – For row-wise coupled matrix models, the pair environment of the atom pair i,j is by default defined as the set of atoms within a spherical cutoff of radius rcut around the atom i.\nn_rep – the number of matrix blocks evaluated per atom pair.\nspecies_substrat – a list of chemical element types. At least one atom of such element types must be within the pair-environemt of two friction-feeling atoms i,j in order for the matrix-block Sigma_ij to be non-zero.\n\n\n\n\n\n","category":"type"},{"location":"function-manual/ACEfriction.MatrixModels/","page":"ACEfriction.MatrixModels","title":"ACEfriction.MatrixModels","text":"mbdpd_matrixmodel","category":"page"},{"location":"function-manual/ACEfriction.MatrixModels/#ACEfriction.mbdpd_matrixmodel","page":"ACEfriction.MatrixModels","title":"ACEfriction.mbdpd_matrixmodel","text":"mbdpd_matrixmodel(property, species_friction, species_env;\nmaxorder=2, \nmaxdeg=5,    \nrcutbond = 5.0, \nrcutenv = 3.0,\nzcutenv = 6.0,\nn_rep = 3, \nspecies_substrat=[], \n)\n\nCreate a matrix model for a momentum-preserving friction model for the simulation of Dissipative Particle Dynamics. The model is a particular parametrization of a pair-wise coupled matrix model.\n\nThis model evaluates blocks Sigma_ij as a function of ellipoid-shaped pair environments centered at the midpoints of the positions of atoms i.j.\n\nArguments:\n\nproperty – the equivariance symmetry wrt SO(3) of matrix blocks. Can be of type  Invariant, EuclideanVector, or EuclideanMatrix.\nspecies_friction – a list of chemical element types. Atoms of these element types \"feel\" friction, i.e., only for atoms of these element types the  matrix model is evaluated, i.e., matrix blocks Sigma_ij are evaluated only if the element types of atoms i and j are contained in species_friction.  \nspecies_env – a list of all chemical element types that affect the evaluation of the friction tensor, i.e., blocks Sigma_ij of friction-feeling atoms i,j are functions of exactly the atoms within the pair environemnt (i,j) whose element type is listed in species_env.\n\nOptional arguments:\n\nmaxorder – the maximum correlaton order of the ACE-basis. A correlation order of n is equivalent to n+1-body interactions.\nmaxdeg – the maximum degree of the polynomial basis functions.\nrcutbond, rcutenv, zcutenv – Parameters of the ellipsoid-shaped pair environments. zcutenv is half of the length of the axis of the elipsoid aligned with the displacement of atoms i,j, and rcutenv is half of the length of the axis perpendicular to the displacement of atoms i,j. rcutbond is the cutoff for the displacement of the atoms i,j, i.e., if the distance between atoms i,j is larger thant rcutbond, then Sigma_ij evaluates to zero.\nn_rep – the number of matrix blocks evaluated per atom pair.\nspecies_substrat – a list of chemical element types. At least one atom of such element types must be within the pair-environemt of two friction-feeling atoms i,j in order for the matrix-block Sigma_ij to be non-zero.\n\n\n\n\n\n","category":"function"},{"location":"fitting-eft/#Fitting-an-Electronic-Friction-Tensor","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"","category":"section"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"In this workflow example we demonstrate how ACEfriction.jl can be used to fit a simple 6 x 6 Electronic friction tensor modeling the non-adiabitic interactions of a hydrogen-atom on a copper surface. ","category":"page"},{"location":"fitting-eft/#Load-Electronic-Friction-Tensor-Data","page":"Fitting an Electronic Friction Tensor","title":"Load Electronic Friction Tensor Data","text":"","category":"section"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"We first use the function load_h5fdata to load the data of friction tensors from a custom-formated hdf5 file and convert the data to the internal data format FrictionData.","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"using ACEfriction\n# Load data \nrdata = ACEfriction.DataUtils.load_h5fdata( \"./test/test-data-100.h5\"); \n# Specify size of training and test data\nn_train = Int(ceil(.8 * length(rdata)))\nn_test = length(rdata) - n_train\n# Partition data into train and test set and convert the data \nfdata = Dict(\"train\" => rdata[1:n_train], \n            \"test\"=> rdata[n_train+1:end]);","category":"page"},{"location":"fitting-eft/#Specify-the-Friction-Model","page":"Fitting an Electronic Friction Tensor","title":"Specify the Friction Model","text":"","category":"section"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"Next, we specify the matrix models that will make up our friction model. In this case we only specify the single matrix model m_equ, which being of the type RWCMatrixModel is based on a row-wise coupling. Alternative for building a friction model with a pairwise coupling is provided in the last of section of this working example.","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"property = EuclideanMatrix()\nspecies_friction = [:H]\nspecies_env = [:Cu]\nm_equ = RWCMatrixModel(property, species_friction, species_env;\n    species_substrat = [:Cu],\n    rcut = 5.0, \n    maxorder = 2, \n    maxdeg = 5,\n);","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"The first argument, property, of the constructor, RWCMatrixModel, specifies the equivariance symmetry of blocks. Here, property is of type EuclideanMatrix specifying each block to  transform like an Euclidean Matrix. In this modeling application, only hydrogen atoms feel friction, which we specify by setting the second argument species_friction to [:H]. Yet, the friction felt by an hydrogen atom is affected by the presence of both hydrogen atoms and copper atoms in its vicinty, which we specify by setting species_env to [:H, :Cu]. Furthermore, the physics is such that hydrogen models only feel friction if they are in contact with the metal surface. We specify this by setting species_substrat = [:Cu]. For further details and information on the remaining optional arguments see the docomentation of the constructor of RWCMatrixModel.","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"Next we build a friction model from the matrix model(s),","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"fm= FrictionModel((mequ=m_equ,)); #fm= FrictionModel((cov=m_cov,equ=m_equ));","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"Here, the mequ serves as the \"ID\" of the friction model m_equ within the friction model. The function get_ids returns the model IDs Wof all matrix model makig up a friction model, i.e.,","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"model_ids = get_ids(fm)","category":"page"},{"location":"fitting-eft/#Set-up-the-Training-Pipeline","page":"Fitting an Electronic Friction Tensor","title":"Set up the Training Pipeline","text":"","category":"section"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"To train our model we first extract the parameters from the friction model, which we use to initialize a structure of type FluxFrictionModel, which serves as a wrapper for the parameters","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"c=params(fm)                                \nffm = FluxFrictionModel(c)","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"Next, the function flux_assemble is used to prepare data for training. This includes evaluating the ACE-basis functions of the matrix models in fm on all configurations in the data set. Since the loss function of our model is quartic polynomial in the parameters, we don't need to reevaluate the ACE-basis functions at later stages of the training process.","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"flux_data = Dict( \"train\"=> flux_assemble(fdata[\"train\"], fm, ffm; ),\n                  \"test\"=> flux_assemble(fdata[\"test\"], fm, ffm));","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"Before starting the training we randomize the parameter values of our model and, if CUDA is available on our device, transform parameters to CUDA compatible cuarrays.","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"set_params!(ffm; sigma=1E-8)\n\nusing CUDA\ncuda = CUDA.functional()\n\nif cuda\n    ffm = fmap(cu, ffm)\nend","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"Finally, we set up the optimizer and data loader, and import the loss functions weighted_l2_loss, which evaluates the training and test loss as","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"mathcalL(c) =  Gamma_rm true - W odot Gamma_rm fit(c) _2^2","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"where odot is the entry-wise Hademard product, and W is a weight matrix assembled during the call of flux_assemble.","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"opt = Flux.setup(Adam(1E-3, (0.99, 0.999)),ffm)\ndloader = cuda ? DataLoader(flux_data[\"train\"] |> gpu, batchsize=10, shuffle=true) : DataLoader(flux_data[\"train\"], batchsize=10, shuffle=true)\nusing ACEfriction.FrictionFit: weighted_l2_loss","category":"page"},{"location":"fitting-eft/#Running-the-Optimizer","page":"Fitting an Electronic Friction Tensor","title":"Running the Optimizer","text":"","category":"section"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"Then, we train the model taking 200 passes through the training data: ","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"loss_traj = Dict(\"train\"=>Float64[], \"test\" => Float64[])\nepoch = 0\nnepochs = 100\nfor _ in 1:nepochs\n    epoch+=1\n    @time for d in dloader\n        ∂L∂m = Flux.gradient(weighted_l2_loss,ffm, d)[1]\n        Flux.update!(opt,ffm, ∂L∂m)       # method for \"explicit\" gradient\n    end\n    for tt in [\"test\",\"train\"]\n        push!(loss_traj[tt], weighted_l2_loss(ffm,flux_data[tt]))\n    end\n    println(\"Epoch: $epoch, Abs avg Training Loss: $(loss_traj[\"train\"][end]/n_train)), Test Loss: $(loss_traj[\"test\"][end]/n_test))\")\nend\nprintln(\"Epoch: $epoch, Abs Training Loss: $(loss_traj[\"train\"][end]), Test Loss: $(loss_traj[\"test\"][end])\")\nprintln(\"Epoch: $epoch, Avg Training Loss: $(loss_traj[\"train\"][end]/n_train), Test Loss: $(loss_traj[\"test\"][end]/n_test)\")","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"Once the training is complete we can extract the updated parameters from the wrapper ffm to parametrize the friction model. ","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"c = params(ffm)\nset_params!(fm, c)","category":"page"},{"location":"fitting-eft/#Evaluating-the-Friction-Model","page":"Fitting an Electronic Friction Tensor","title":"Evaluating the Friction Model","text":"","category":"section"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"The trained friction model can be used to evaluate the friction tensor bm Gamma and diffusion coeccifient matrix bm Sigma at configurations as follows ","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"at = fdata[\"test\"][1].atoms # extract atomic configuration from the test set\nGamma(fm, at) # evaluate the friction tensor\nΣ = Sigma(fm, at) # evaluate the diffusion coeffcient matrix","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"To simulate a Langevin equation, typically, both the friction coefficient and the diffusion coefficient matrix must be evaluated. Instead of evaluating them seperately it is more efficient to first evaluate the diffusion coefficient matrix and then evaluate the friction tensor from the the pre-computed diffusion coefficient matrix:","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"Σ = Sigma(fm, at) # evaluate the diffusion coeffcient matrix\nGamma(fm, Σ) # compute the friction tensor from the pre-computeed diffusion coefficient matrix.","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"The diffusion coefficient matrix Sigma can also be used to efficiently generate Gaussian pseudo random numbers rm Normal(0bf Gamma) as ","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"R = randf(fm,Σ)","category":"page"},{"location":"fitting-eft/#fitting-pairwise-coupling","page":"Fitting an Electronic Friction Tensor","title":"Friction Model with a Pairwise Coupling","text":"","category":"section"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"Instead of using a row-wise coupling, we can also use a pairwise coupling to construct a friction model. The following code produces a friction model with a pairwise coupling:","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"property = EuclideanMatrix(Float64)\nspecies_friction = [:H]\nspecies_env = [:Cu,:H]\n\nm_equ = PWCMatrixModel(property, species_friction,  species_env;\n        z2sym = NoZ2Sym(), \n        speciescoupling = SpeciesUnCoupled(),\n        species_substrat = [:Cu],\n        n_rep = 1,\n        maxorder=2, \n        maxdeg=5, \n        rcut= 5.0, \n    );\n\nm_equ0 = OnsiteOnlyMatrixModel(property, species_friction,  species_env;\n    species_substrat=[:Cu], \n    id=:equ0, \n    n_rep = 1, \n    rcut = rcut, \n    maxorder=2, \n    maxdeg=5\n);\n\nfm= FrictionModel((mequ_off = m_equ, mequ_on=m_equ0)); \n","category":"page"},{"location":"function-manual/ACEfriction.FrictionFit/","page":"ACEfriction.FrictionFit","title":"ACEfriction.FrictionFit","text":"CurrentModule = ACEfriction.FrictionFit","category":"page"},{"location":"function-manual/ACEfriction.FrictionFit/","page":"ACEfriction.FrictionFit","title":"ACEfriction.FrictionFit","text":"flux_assemble","category":"page"},{"location":"function-manual/ACEfriction.FrictionFit/#ACEfriction.FrictionFit.flux_assemble","page":"ACEfriction.FrictionFit","title":"ACEfriction.FrictionFit.flux_assemble","text":"flux_assemble(fdata::Array{DATA}, fm::FrictionModel, ffm::FluxFrictionModel; weights = Dict(\"observations\" => ones(length(fdata)), \"diag\" => 2.0, \"sub_diag\" => 1.0, \"off_diag\"=>1.0)) where {DATA<:FrictionData}\n\nConverts FrictionData into a format that can be used for training with ffm::FluxFrictionModel \n\n\n\n\n\n","category":"function"},{"location":"function-manual/ACEfriction.FrictionFit/","page":"ACEfriction.FrictionFit","title":"ACEfriction.FrictionFit","text":"FluxFrictionModel","category":"page"},{"location":"function-manual/ACEfriction.FrictionFit/#ACEfriction.FrictionFit.FluxFrictionModel","page":"ACEfriction.FrictionFit","title":"ACEfriction.FrictionFit.FluxFrictionModel","text":"FluxFrictionModel(c::NamedTuple{model_ids}) where {model_ids}\n\nCreate a FluxFrictionModel with the parameters c and the model ids model_ids.\n\nArguments\n\nc::NamedTuple{model_ids} : The parameters of the model.\n\n\n\n\n\n","category":"type"},{"location":"function-manual/ACEfriction.FrictionFit/","page":"ACEfriction.FrictionFit","title":"ACEfriction.FrictionFit","text":"get_ids","category":"page"},{"location":"function-manual/ACEfriction.FrictionFit/#ACEfriction.FrictionModels.get_ids","page":"ACEfriction.FrictionFit","title":"ACEfriction.FrictionModels.get_ids","text":"get_ids(m::FluxFrictionModel)\n\nReturn the model ids of the model m.\n\n\n\n\n\n","category":"function"},{"location":"function-manual/ACEfriction.FrictionFit/","page":"ACEfriction.FrictionFit","title":"ACEfriction.FrictionFit","text":"l2_loss","category":"page"},{"location":"function-manual/ACEfriction.FrictionFit/#ACEfriction.FrictionFit.l2_loss","page":"ACEfriction.FrictionFit","title":"ACEfriction.FrictionFit.l2_loss","text":"l2_loss(fm, data)\n\nCompute the L2 loss of the model fm on the data data.\n\n\n\n\n\n","category":"function"},{"location":"function-manual/ACEfriction.FrictionFit/","page":"ACEfriction.FrictionFit","title":"ACEfriction.FrictionFit","text":"weighted_l2_loss","category":"page"},{"location":"function-manual/ACEfriction.FrictionFit/#ACEfriction.FrictionFit.weighted_l2_loss","page":"ACEfriction.FrictionFit","title":"ACEfriction.FrictionFit.weighted_l2_loss","text":"weighted_l2_loss(fm, data)\n\nCompute the weighted L2 loss of the model fm on the data data.\n\n\n\n\n\n","category":"function"},{"location":"function-manual/ACEfriction.FrictionFit/","page":"ACEfriction.FrictionFit","title":"ACEfriction.FrictionFit","text":"weighted_l1_loss","category":"page"},{"location":"function-manual/ACEfriction.FrictionFit/#ACEfriction.FrictionFit.weighted_l1_loss","page":"ACEfriction.FrictionFit","title":"ACEfriction.FrictionFit.weighted_l1_loss","text":"weighted_l1_loss(fm, data)\n\nCompute the weighted L1 loss of the model fm on the data data.\n\n\n\n\n\n","category":"function"},{"location":"overview/#Model-Overview","page":"Overview","title":"Model Overview","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"The package ACEfriction provides an ACE-based implementation of the size-transferrable, E(3)-equivariant models introduced in Sachs et al., (2024) for configuration-dependent friction or diffusion tensors.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"In a nutshell, the package provides utilities to efficiently learn and evaluate E(3)-equivariant symmetric positive semi-definite matrix functions of the form","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"bm Gamma left ( (bm r_iz_i)_i=1^N_rm at right ) in mathbbR^3 N_rm at times 3N_rm at","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"where the bm r_is are the positions and the z_is are the atomic element types of atoms in an atomic configuration comprised of N_rm at atoms.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The underlying model is based on an equivariance-preserving matrix square root decomposition,","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"bm Gamma = bm Sigmabm Sigma^T","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"where block entries of the matrix square root bm Sigmaleft ( (bm r_iz_i)_i=1^N_rm at right ) in mathbbR^3 N_rm at times m with some m in mathbbN, are linearly expanded using an equivariant linear atomic cluster expansion.","category":"page"},{"location":"overview/#Code-Overview","page":"Overview","title":"Code Overview","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"The package ACEfriction is comprised of three main sub-modules:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The sub-module FrictionModels implements the structure FrictionModel, which facilitates the specification of and evaluation of friction models. The module implements the functions Gamma(fm::FrictionModel, at::Atoms), Sigma(fm::FrictionModel, at::Atoms) which evaluate the friction model fm at the atomic configuration at to the correspong friction tensor bm Gamma and  diffusion coefficient matrix bm Sigma, respectively. Moreover, it provides the functions Gamma(fm::FrictionModel, Σ), randf(fm::FrictionModel, Σ) for efficient computation of the friction tensor and generation of rm Normal(bm 0 bm Gamma)-distributed Gaussian random numbers from a precomputed diffusion coeffiient matrix Σ.\nThe sub-module MatrixModels implements various matrix models, which make up a friction model and, in essence, specify (i) properties of the ACE-basis used to evaluate blocks bm Sigma_ij of the difffusion matrix, and (ii) how blocks  bm Sigma_ij are combined in the assembly of the friction tensor bm Gamma. The assembly of the friction tensor is governed by what is referred to in Sachs et al., (2024) as the coupling scheme and implements versions of the the pair-wise coupling and row-wise coupling described therein.\nThe sub-module FrictionFit provides utility functions for training of friction models using the julia machine learning library Flux.jl. ","category":"page"},{"location":"overview/#Prototypical-Applications","page":"Overview","title":"Prototypical Applications","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Learned models of bm Gamma (and the corresponding matrix root bm Sigma) can be used to parametrize tensor-valued coefficients in an Itô diffusion process such as a configuration-dependent friction tensor in a kinetic Langevin equation,","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"beginaligned\ndotbm r = - M^-1bm p\ndotbm p = - nabla U(bm r) - bm Gamma(bm r)M^-1bm p + sqrt2 beta^-1 bm Sigma dotbm W\nendaligned","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"or a configuration-dependent diffusion tensor in an overdamped Langevin equation,","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"dotbm r = - bmGamma(bm r) nabla U(bm r)  + sqrt2 beta^-1 bmSigmacirc dotbm W + beta^-1rm div(bm Gamma(r))","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The model and code allows imposing additional symmetry constraints on the matrix bm Gamma. In particular, the learned friction-tensor bm Gamma can be specified to satisfy relevant symmetries for the dynamics (1) to be momentum-conserving, thus enabling learning and simulation of Multi-Body Dissipative Particle Dynamics (MD-DPD).","category":"page"},{"location":"installation/#Prerequisites","page":"Installation Guide","title":"Prerequisites","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"You will need to have Julia (v1.7 or newer) installed. The latest release and installation instruction for Julia are available here here.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"warning: Warning\nIf you are running Julia for the first time, there is a chance that the General Registrity is not added to you installation. To install the General Registry run the following code from within a Julia REPL.using Pkg\nPkg.Registry.add(\"General\")  ","category":"page"},{"location":"installation/#Installation","page":"Installation Guide","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"The package ACEfriction and some required dependencies can be downloaded from ACEregistry. To add this registry and install ACEfriction execute the following steps from within a Julia REPL. ","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Add the ACEregistry registry:\nusing Pkg\nPkg.Registry.add(RegistrySpec(url=\"https://github.com/ACEsuit/ACEregistry\"))\nInstall ACEfriction:\nPkg.add(\"ACEfriction\")","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Done! Now you can use the functionality of ACEfriction in your project by running using ACEfriction.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"note: Note\nIt is recommended to install ACEfriction within a dedicated julia environment, where approriate version bounds can be set within the Project.toml file, and versions of dependencies are tracked in a Manifest.toml file. To create a new project, simply create a new directory, navigate to that directory and runPkg.activate(\".\")Then, execute sthe teps 1. and 2. from within the project directory. ","category":"page"},{"location":"function-manual/ACEfriction.DataUtils/","page":"ACEfriction.DataUtils","title":"ACEfriction.DataUtils","text":"CurrentModule = ACEfriction.DataUtils","category":"page"},{"location":"function-manual/ACEfriction.DataUtils/","page":"ACEfriction.DataUtils","title":"ACEfriction.DataUtils","text":"The submodule ACEfriction.DataUtils.jl provides structures to internally store friction data in ACEfriction.jl and functions to import and export friction data from and to custom formatted hdf5 files.","category":"page"},{"location":"function-manual/ACEfriction.DataUtils/#friction-data-representation","page":"ACEfriction.DataUtils","title":"Friction Data representation","text":"","category":"section"},{"location":"function-manual/ACEfriction.DataUtils/","page":"ACEfriction.DataUtils","title":"ACEfriction.DataUtils","text":"For pre-training storage and manipulation of friction data, ACEfriction.jl implements the structure FrictionData to represent a single observation (R_iGamma_i) of an atomic configuration R_i and corresponding friction tensor Gamma_i: ","category":"page"},{"location":"function-manual/ACEfriction.DataUtils/","page":"ACEfriction.DataUtils","title":"ACEfriction.DataUtils","text":"struct FrictionData\n    atoms\n    friction_tensor\n    friction_indices\nend","category":"page"},{"location":"function-manual/ACEfriction.DataUtils/","page":"ACEfriction.DataUtils","title":"ACEfriction.DataUtils","text":"where","category":"page"},{"location":"function-manual/ACEfriction.DataUtils/","page":"ACEfriction.DataUtils","title":"ACEfriction.DataUtils","text":"atoms – stores data of the atomic configuration ans is assumed to be of type JuLIP.Atoms,\nfriction_tensor – stores data on the friction tensor and is assumed to be of typeSparseMatrix{SMatrix{3, 3, T, 9}}, where T<:Float and Ti<:Int. That is, the friction tensor is stored in the form of sparse matrices with 3 times 3-matrix valued block entries,\nfriction_indices –  is a one-dimensional integer array, which contains all atom indices for which the friction tensor is defined.","category":"page"},{"location":"function-manual/ACEfriction.DataUtils/#Importing-and-Exporting-Friction-Data","page":"ACEfriction.DataUtils","title":"Importing & Exporting Friction Data","text":"","category":"section"},{"location":"function-manual/ACEfriction.DataUtils/","page":"ACEfriction.DataUtils","title":"ACEfriction.DataUtils","text":"ACEfriction.DataUtils implements the function save_h5fdata to save arrays of friction data to a custom  formatted hdf5 file, as well as the function load_h5fdata to load friction data from such costum formatted hdf5 files:","category":"page"},{"location":"function-manual/ACEfriction.DataUtils/","page":"ACEfriction.DataUtils","title":"ACEfriction.DataUtils","text":"save_h5fdata","category":"page"},{"location":"function-manual/ACEfriction.DataUtils/#ACEfriction.DataUtils.save_h5fdata","page":"ACEfriction.DataUtils","title":"ACEfriction.DataUtils.save_h5fdata","text":"save_h5fdata(rdata::Vector{FrictionData}, filename::String )\n\nSaves a friction tensor data in a costum formatted hdf5 file.\n\nArguments\n\nrdata : Vector{FrictionData} :   A vector of friction data entries. Each entry is a structure of type Frictiondata with the following fields:\nat : JuLIP.Atoms : Atoms object containing the atomic positions, cell, and periodic boundary conditions.\nfriction_tensor : SparseMatrix{SMatrix{3,3,Float64,9}} : Sparse matrix representation of the friction tensor.\nfriction_indices : Vector{Int} : Indices of the atoms for which the friction tensor is defined.\nfilename : String : Name of the file to save to (including h5 extension).\n\n\n\n\n\n","category":"function"},{"location":"function-manual/ACEfriction.DataUtils/","page":"ACEfriction.DataUtils","title":"ACEfriction.DataUtils","text":"load_h5fdata","category":"page"},{"location":"function-manual/ACEfriction.DataUtils/#ACEfriction.DataUtils.load_h5fdata","page":"ACEfriction.DataUtils","title":"ACEfriction.DataUtils.load_h5fdata","text":"load_h5fdata(filename::String)\n\nLoads a friction tensor data from a costum formatted hdf5 file.\n\nArguments\n\nfilename : String : Name of the file to load from (including h5 extension).\n\nReturns\n\nrdata : Vector{FrictionData} :   A vector of friction data entries. Each entry is a structure of type Frictiondata with the following fields:\nat : JuLIP.Atoms : Atoms object containing the atomic positions, cell, and periodic boundary conditions.\nfriction_tensor : SparseMatrix{SMatrix{3,3,Float64,9}} : Sparse matrix representation of the friction tensor.\nfriction_indices : Vector{Int} : Indices of the atoms for which the friction tensor is defined.\n\n\n\n\n\n","category":"function"},{"location":"function-manual/ACEfriction.DataUtils/#costum-hdf5-format","page":"ACEfriction.DataUtils","title":"Custom HDF5 File Format for Friction Data","text":"","category":"section"},{"location":"function-manual/ACEfriction.DataUtils/","page":"ACEfriction.DataUtils","title":"ACEfriction.DataUtils","text":"The hierachical structure of such hdf5 files is as follows:","category":"page"},{"location":"function-manual/ACEfriction.DataUtils/","page":"ACEfriction.DataUtils","title":"ACEfriction.DataUtils","text":"Each observation (R_iGamma_i) is saved in a separate group in named by respective index i, i.e., we have the following groups on root level of the hdf5 file:","category":"page"},{"location":"function-manual/ACEfriction.DataUtils/","page":"ACEfriction.DataUtils","title":"ACEfriction.DataUtils","text":"├─ 📂 1   \n├─ 📂 2  \n├─ 📂 3   \n│  :   \n├─ 📂 N_obs   ","category":"page"},{"location":"function-manual/ACEfriction.DataUtils/","page":"ACEfriction.DataUtils","title":"ACEfriction.DataUtils","text":"Within each of these groups, the data of the respective  atomic configuration R_i and friction tensor Gamma_i are saved in the subgroups atoms and friction_tensor, respectively: ","category":"page"},{"location":"function-manual/ACEfriction.DataUtils/","page":"ACEfriction.DataUtils","title":"ACEfriction.DataUtils","text":"├─ 📂 i                        # Index of data point \n   ├─ 📂 atoms                 # Atom configuration data\n   │  ├─ 🔢 atypes\n   │  ├─ 🔢 cell \n   │  │  └─ 🏷️ column_major \n   │  ├─ 🔢 pbc\n   │  └─ 🔢 positions\n   │     └─ 🏷️ column_major\n   └─ 📂 friction_tensor       # Friction tensor data\n      ├─ 🔢 ft_I               \n      ├─ 🔢 ft_J\n      ├─ 🔢 ft_mask\n      └─ 🔢 ft_val, \n         └─ 🏷️ column_major","category":"page"},{"location":"function-manual/ACEfriction.DataUtils/","page":"ACEfriction.DataUtils","title":"ACEfriction.DataUtils","text":"Datasets in the group atoms store the equivalent information provided by the attributes  positions, numbers, cell, and pbc of atoms objects, i.e.,  an atomic configuration of N atoms is described by the following datasets contained in the group atoms:","category":"page"},{"location":"function-manual/ACEfriction.DataUtils/","page":"ACEfriction.DataUtils","title":"ACEfriction.DataUtils","text":"atypes – A one-dimensional Integer dataset of length N. The ith entry corresponds to the atomic element number of the ith atom in the configuration. (Note: types corresponds to the atoms attribute numbers in the ase.)\ncell – A two-dimensional Float64 dataset of size 3 x 3. \npbc – A one-dimensional Integer array of length 3 indicating the periodicity properties of the xyz dimension, e.g., pbc = [1,0,0] describes periodic boundary conditions in x dimension and non-periodic boundary conditions in the y and z dimensions. \npositions – A two-dimensional Float64 dataset of size n N x 3. The ith column corresponds to the position of the ith atom in the configuration ","category":"page"},{"location":"function-manual/ACEfriction.DataUtils/","page":"ACEfriction.DataUtils","title":"ACEfriction.DataUtils","text":"Datasets in the group friction_tensor store the friction tensor as a N x N sparse matrix with 3x3 valued block entries,  i.e., a friction tensor with m non-zero 3x3 blocks is stored","category":"page"},{"location":"function-manual/ACEfriction.DataUtils/","page":"ACEfriction.DataUtils","title":"ACEfriction.DataUtils","text":"ft_I – A one-dimensional Integer dataset of length m specifying the column indices of non-zero block entries of the friction tensor.\nft_J – A one-dimensional Integer dataset of length m specifying the row indices of non-zero block entries of the friction tensor.\nft_val – A three-dimensional Float64 dataset of size m x 3 x 3 specifying the values of the non-zero 3 x 3 block entries of  the friction tensor. For example, the 3 x 3 array ft_val[k,:,:] corresponds to the 3 x 3 block entry of the friction tensor with column index ft_I[k], and row index ft_J[k]. \nft_mask – A one-dimensional Integer dataset/list containg the indices of atoms for which friction information is provided. ","category":"page"},{"location":"function-manual/ACEfriction.DataUtils/","page":"ACEfriction.DataUtils","title":"ACEfriction.DataUtils","text":"warning: Warning\nAll two or three-dimensional datasets in the groups atoms and friction_tensor have an additional attribute column_major. If the hdf5 file is created in a language that stores matrices in column-major form (e.g., julia), this attribute must be set to 1 (True). If the hdf5 file is created in a language that stores matrices in column-major form (e.g., python), this attribute must be set to 0 (False).","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The julia package ACEfriction.jl facilitates simulation and machine learning of configuration-dependent friction tensor models from data. The models are based on an equivariant Atomic Cluster Expansion (ACE) and, as such, are computationally highly efficient and size transferable. The underlying framework of model construction is described in detail in Sachs et al., (2024).  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"For a quick start, we recommend reading the Installation Instructions and the Overview section, followed by the Workflow Examples. Detailed documentation of front-end-facing functions can be found in the Function Manual.  ","category":"page"},{"location":"#ACEfriction-paper","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you are using ACEfriction.jl in your work, please cite the following article: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Sachs, M., Stark, W. G., Maurer, R. J., & Ortner, C. (2024). Equivariant Representation of Configuration-Dependent Friction Tensors in Langevin Heatbaths. [arxiv]","category":"page"},{"location":"function-manual/ACEfriction.FrictionModels/","page":"ACEfriction.FrictionModels","title":"ACEfriction.FrictionModels","text":"CurrentModule = ACEfriction.FrictionModels","category":"page"},{"location":"function-manual/ACEfriction.FrictionModels/","page":"ACEfriction.FrictionModels","title":"ACEfriction.FrictionModels","text":"A friction model is a wrapper around a named tuple of matrix models, i.e. ","category":"page"},{"location":"function-manual/ACEfriction.FrictionModels/","page":"ACEfriction.FrictionModels","title":"ACEfriction.FrictionModels","text":"struct FrictionModel{MODEL_IDS} <: AbstractFrictionModel\n    matrixmodels::NamedTuple{MODEL_IDS} \nend","category":"page"},{"location":"function-manual/ACEfriction.FrictionModels/","page":"ACEfriction.FrictionModels","title":"ACEfriction.FrictionModels","text":"The symbols contained in the tuple MODEL_IDS are referred to as \"IDs\" of the corresponding matrix models. When evaluated at an atomic configuration, the resulting friction tensor is the sum of the friction tensors of all matrix models in the friction model, whereas diffusion coefficient matrices are evaluated seperately for each matrix model and returned in the form of a named tuple of the same signature. The following functions act on structures of type FrictionModel: ","category":"page"},{"location":"function-manual/ACEfriction.FrictionModels/","page":"ACEfriction.FrictionModels","title":"ACEfriction.FrictionModels","text":"Gamma","category":"page"},{"location":"function-manual/ACEfriction.FrictionModels/#ACEfriction.FrictionModels.Gamma","page":"ACEfriction.FrictionModels","title":"ACEfriction.FrictionModels.Gamma","text":"Gamma(fm::FrictionModel, at::Atoms; filter=(_,_)->true, T=Float64)\n\nEvaluates the friction tensor according to the friction model fm at the atomic configuration at::Atoms. The friction tensor is the sum of the friction tensors of all matrix models in fm.matrixmodels.\n\nArguments:\n\nfm – the friction model of which the friction tensor is evaluated.\nat – the atomic configuration at which the basis is evaluated\nfilter  – (optional, default: (_,_)->true) a filter function of the generic form (i::Int,at::Atoms) -> Bool. Only atoms at[i] for which filter(i,at) returns true are included in the evaluation of the friction tensor.  \n\nOutput:\n\nA friction tensor in the form of a sparse 3N x 3N matrix, where N is the number of atoms in the atomic configuration at.  \n\n\n\n\n\nGamma(fm::FrictionModel{MODEL_IDS}, Σ_vec::NamedTuple{MODEL_IDS}) where {MODEL_IDS}\n\nComputes the friction tensor from a pre-computed collection of diffusion coefficient matrices.  The friction tensor is the sum of the squares of all diffusion coefficient matrices in the collection.\n\nArguments:\n\nfm – the friction model of which the friction tensor is evaluated. The friction tensor is the sum of the friction tensors of all matrix models in fm.matrixmodels.\nΣ – a collection of diffusion coefficient matrices. The friction tensor is the sum of the squares of all matrices in Σ.\n\nOutput:\n\nA friction tensor in the form of a sparse 3N x 3N matrix, where N is the number of atoms in the atomic configuration at.  The friction tensor is the sum of the symmetric squares SigmaSigma^T of all diffusion coefficient matrices Sigma in Σ_vec.\n\n\n\n\n\n","category":"function"},{"location":"function-manual/ACEfriction.FrictionModels/","page":"ACEfriction.FrictionModels","title":"ACEfriction.FrictionModels","text":"Sigma","category":"page"},{"location":"function-manual/ACEfriction.FrictionModels/#ACEfriction.FrictionModels.Sigma","page":"ACEfriction.FrictionModels","title":"ACEfriction.FrictionModels.Sigma","text":"Sigma(fm::FrictionModel{MODEL_IDS}, at::Atoms; filter=(_,_)->true, T=Float64) where {MODEL_IDS}\n\nComputes the diffusion coefficient matrices for all matrix models in the friction model at a given configuration.\n\nArguments:\n\nfm – the friction model of which the diffusion coefficient matrices are evaluated\nat – the atomic configuration at which the diffusion coefficient matrices are evaluated\nfilter  – (optional, default: (_,_)->true) a filter function of the generic form (i::Int,at::Atoms) -> Bool. Only atoms at[i] for which filter(i,at) returns true are included in the evaluation of the diffusion coefficient matrices.\n\nOutput:\n\nA NamedTuple of diffusion coefficient matrices, where the keys are the IDs of the matrix models in the friction model.\n\n\n\n\n\n","category":"function"},{"location":"function-manual/ACEfriction.FrictionModels/","page":"ACEfriction.FrictionModels","title":"ACEfriction.FrictionModels","text":"randf","category":"page"},{"location":"function-manual/ACEfriction.FrictionModels/#ACEfriction.MatrixModels.randf","page":"ACEfriction.FrictionModels","title":"ACEfriction.MatrixModels.randf","text":"randf(fm::FrictionModel{MODEL_IDS}, Σ::NamedTuple{MODEL_IDS}) where {MODEL_IDS}\n\nGenerates a rm Normal(bm 0 bm Gamma)-distributed Gaussian pseudo random number from a precomputed diffusion coeffiient matrices.\n\nArguments:\n\nfm – the friction model of which the friction tensor is evaluated. The friction tensor is the sum of the friction tensors of all matrix models in fm.matrixmodels.\nΣ – a collection of diffusion coefficient matrices. The friction tensor is the sum of the squares of all matrices in Σ.\n\nOutput:\n\nA rm Normal(bm 0 bm Gamma)-distributed Gaussian vector R::Vector{3,Float64} of length N, where N is the number of atoms in the configuration for which Σ was evaluated.\n\n\n\n\n\n","category":"function"},{"location":"function-manual/ACEfriction.FrictionModels/","page":"ACEfriction.FrictionModels","title":"ACEfriction.FrictionModels","text":"basis","category":"page"},{"location":"function-manual/ACEfriction.FrictionModels/#ACEfriction.MatrixModels.basis","page":"ACEfriction.FrictionModels","title":"ACEfriction.MatrixModels.basis","text":"basis(fm::FrictionModel{MODEL_IDS}, at::Atoms; join_sites=false, filter=(_,_)->true, T=Float64) where {MODEL_IDS}\n\nEvaluates the ACE-basis functions of the friction model fm at the atomic configuration at::Atoms.\n\nArguments:\n\nfm – the friction model of which the basis is evaluated\nat – the atomic configuration at which the basis is evaluated\njoin_sites – (optional, default: false) if true, the basis evaulations of all matrix models are concatenated into a single array. If false, the basis evaluations are returned as a named tuple of the type NamedTuple{MODEL_IDS}.\nfilter  – (optional, default: (_,_)->true) a filter function of the generic form (i::Int,at::Atoms) -> Bool. The atom at[i] will be included in the basis iff filter(i,at) returns true.  \n\n\n\n\n\n","category":"function"},{"location":"function-manual/ACEfriction.FrictionModels/#Setter-and-getter-functions-for-model-parameters","page":"ACEfriction.FrictionModels","title":"Setter and getter functions for model parameters","text":"","category":"section"},{"location":"function-manual/ACEfriction.FrictionModels/","page":"ACEfriction.FrictionModels","title":"ACEfriction.FrictionModels","text":"params","category":"page"},{"location":"function-manual/ACEfriction.FrictionModels/#ACE.params","page":"ACEfriction.FrictionModels","title":"ACE.params","text":"params(fm::FrictionModel{MODEL_IDS}) where {MODEL_IDS}\n\nReturns the parameters of all matrix models in the FrictionModel object as a NamedTuple.\n\n\n\n\n\nparams(m::FluxFrictionModel; transformed=true)\n\nReturn the parameters of the model m.\n\n\n\n\n\n","category":"function"},{"location":"function-manual/ACEfriction.FrictionModels/","page":"ACEfriction.FrictionModels","title":"ACEfriction.FrictionModels","text":"nparams","category":"page"},{"location":"function-manual/ACEfriction.FrictionModels/#ACE.nparams","page":"ACEfriction.FrictionModels","title":"ACE.nparams","text":"nparams(fm::FrictionModel{MODEL_IDS}) where {MODEL_IDS}\n\nReturns the total number of scalar parameters of all matrix models in the FrictionModel object.\n\n\n\n\n\n","category":"function"},{"location":"function-manual/ACEfriction.FrictionModels/","page":"ACEfriction.FrictionModels","title":"ACEfriction.FrictionModels","text":"set_params!","category":"page"},{"location":"function-manual/ACEfriction.FrictionModels/#ACE.set_params!","page":"ACEfriction.FrictionModels","title":"ACE.set_params!","text":"set_params!(fm::FrictionModel, θ::NamedTuple)\n\nSets the parameters of all matrix models in the FrictionModel object whose ID is contained in θ::NamedTuple to the values specified therein.\n\n\n\n\n\nset_params!(m::FluxFrictionModel; sigma=1E-8, model_ids::Array{Symbol}=Symbol[])\n\nRandomizes the parameters of the model m.\n\nArguments\n\nm::FluxFrictionModel: The model to set the parameters of.\nsigma::Float64=1E-8: The standard deviation of the random values.\nmodel_ids::Array{Symbol}=[]: The ids of the models to set the parameters of. If empty, all the parameters are set.\n\n\n\n\n\nset_params!(m::FluxFrictionModel, c_new::NamedTuple)\n\nSet the parameters of the model to the values in c_new.\n\nArguments\n\nm::FluxFrictionModel: The model to set the parameters of.\nc_new::NamedTuple: The new parameters.  The keys of c_new should be a subset of m.model_ids.\n\n\n\n\n\n","category":"function"},{"location":"function-manual/ACEfriction.FrictionModels/","page":"ACEfriction.FrictionModels","title":"ACEfriction.FrictionModels","text":"set_zero!","category":"page"},{"location":"function-manual/ACEfriction.FrictionModels/#ACEfriction.MatrixModels.set_zero!","page":"ACEfriction.FrictionModels","title":"ACEfriction.MatrixModels.set_zero!","text":"set_zero!(fm::FrictionModel, model_ids)\n\nSets the parameters of all matrix models in the FrictionModel object to zero.\n\n\n\n\n\n","category":"function"}]
}

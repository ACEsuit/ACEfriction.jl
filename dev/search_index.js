var documenterSearchIndex = {"docs":
[{"location":"fitting-mbdpd/#Fitting-a-Friction-Tensor-for-Simulation-of-(Multi-Body)-Dissipative-Particle-Dynamics","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Friction Tensor for Simulation of (Multi-Body) Dissipative Particle Dynamics","text":"","category":"section"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"In this workflow example we demonstrate how ACEfriction.jl can be used to fit a momentum-conserving friction tensor as used in Dissipative Particle Dynamics. ","category":"page"},{"location":"fitting-mbdpd/#Background-on-Dissipative-Particle-Dynamics","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Background on Dissipative Particle Dynamics","text":"","category":"section"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"Dissipative particle dynamics can be considered as a special version of the Langevin equation @ref, where the friction tensor Gamma is such that the total momentum is conserved, i.e.","category":"page"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"fracddtsum_i p_i(t) = bf 0","category":"page"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"In order for this to be the case, the friction tensor must satisfy the constraint","category":"page"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"sum_iGamma_ij = bf 0 text for every  j=1dots N_rm at","category":"page"},{"location":"fitting-mbdpd/#Momentum-conserving-Friction-Models-in-ACEfriction.jl","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Momentum-conserving Friction Models in ACEfriction.jl","text":"","category":"section"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"ACEfriction.jl provides utility functions for the construction of momentum-conserving friction models. Namely, the function mbdpd_matrixmodel yields a pair-wise coupled matrix model with additional symmetries such that resulting friction model satisfies the above constraints. For example, ","category":"page"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"m_cov = mbdpd_matrixmodel(EuclideanVector(), [:X], [:X];\n    maxorder=1, \n    maxdeg=5,    \n    rcutbond = 5.0, \n    rcutenv = 5.0,\n    zcutenv = 5.0,\n    n_rep = 1, \n    )\nfm= FrictionModel((m_cov=m_cov,)); ","category":"page"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"results in a momentum-conserving friction model with vector-equivariant blocks in the diffusion matrix. Here, the model is specified for the artifical atom element type :X.","category":"page"},{"location":"fitting-mbdpd/#Fit-Friction-Model-to-Synthetic-DPD-Friction-Data","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fit Friction Model to Synthetic DPD Friction Data","text":"","category":"section"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"The following code loads training and test data comprised of particle configurations and corresponding friction tensors:","category":"page"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"rdata_train = ACEfriction.DataUtils.load_h5fdata(\"./examples/data/dpd-train-x.h5\"); \nrdata_test = ACEfriction.DataUtils.load_h5fdata(\"./examples/data/dpd-train-x.h5\"); \n\nfdata = Dict(\"train\" => FrictionData.(rdata_train), \n            \"test\"=> FrictionData.(rdata_test));\n(n_train, n_test) = length(fdata[\"train\"]), length(fdata[\"test\"])","category":"page"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"Here the training data is contains friction tensors of 50 configurations each comprised of 64 particles, and the test data contains friction tensors of 10 configurations each comprised of 216 particles. The underlying friction tensors were synthetically generated using the following simple friction model, which is a smooth version of the standard heuristic DPD friction models commonly used in simulations: ","category":"page"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"Gamma_ij( (bf r_kz_k )_k=1^N_rm at) = begincases\ngamma(r_ij) hatbf r_ij otimes hatbf r_ji i neq j \n-sum_k neq i Gamma_ki i = j\nendcases","category":"page"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"where bf r_ij = bf r_j - bf r_i,  r_ij = bf r_ij_2, hatbf r_ij = bf r_ijr_ij, and","category":"page"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"gamma(r) = w exp left (-frac11-(rr_rm cut)^2 right ) ","category":"page"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"with weight w=50 and cutoff distance r_rm cut=50.","category":"page"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"To fit the model we execute exactly the same steps as in the previous example:","category":"page"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"ffm = FluxFrictionModel(params(fm;format=:matrix, joinsites=true))\nflux_data = Dict( \"train\"=> flux_assemble(fdata[\"train\"], fm, ffm),\n                  \"test\"=> flux_assemble(fdata[\"test\"], fm, ffm));\n\n\nloss_traj = Dict(\"train\"=>Float64[], \"test\" => Float64[])\nepoch = 0\nbatchsize = 10\nnepochs = 100\nopt = Flux.setup(Adam(1E-2, (0.99, 0.999)),ffm)\ndloader = DataLoader(flux_data[\"train\"], batchsize=batchsize, shuffle=true)\n\nfor _ in 1:nepochs\n    epoch+=1\n    @time for d in dloader\n        ∂L∂m = Flux.gradient(weighted_l2_loss,ffm, d)[1]\n        Flux.update!(opt,ffm, ∂L∂m)       # method for \"explicit\" gradient\n    end\n    for tt in [\"test\",\"train\"]\n        push!(loss_traj[tt], weighted_l2_loss(ffm,flux_data[tt]))\n    end\n    println(\"Epoch: $epoch, Abs avg Training Loss: $(loss_traj[\"train\"][end]/n_train)), Test Loss: $(loss_traj[\"test\"][end]/n_test))\")\nend","category":"page"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"After training for 2000 epochs, the resulting model is almost a perfect fit:","category":"page"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"(Image: True vs fitted entries of the friction tensor)             True vs fitted entries of the friction tensor.","category":"page"},{"location":"fitting-mbdpd/#Multi-Body-Dissipative-Particle-Dynamics","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Multi-Body Dissipative Particle Dynamics","text":"","category":"section"},{"location":"fitting-mbdpd/","page":"Fitting a Dissipative Particle Dynamics Friction Model","title":"Fitting a Dissipative Particle Dynamics Friction Model","text":"By specifying maxorder=1 in the above construction of the friction model, we restrict the underlying ACE-basis to only incorporate pair-wise interactions. This is fine for the here considered sythentic data as the underlying toy model is in fact based on only pair-wise interactions. However, in more complex systems  the random force and the dissipative force may not decompose to pairwise interactions. To incorporate higher body-order interactions in the friction model, say interactions up to body order 4, we can change the underlying ACE-basis expansion to incorporate correlation terms up to order 3 by setting maxorder=3. ","category":"page"},{"location":"fitting-eft/#Fitting-an-Electronic-Friction-Tensor","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"","category":"section"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"In this workflow example we demonstrate how ACEfriction.jl can be used to fit a simple 6 x 6 Electronic friction tensor modeling the non-adiabitic interactions of a hydrogen-atom on a copper surface. ","category":"page"},{"location":"fitting-eft/#Load-Electronic-Friction-Tensor-Data","page":"Fitting an Electronic Friction Tensor","title":"Load Electronic Friction Tensor Data","text":"","category":"section"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"We first use the function load_h5fdata to load the data of friction tensors from a custom-formated hdf5 file and convert the data to the internal data format [FrictionData].","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"using ACEfriction\n# Load data \nrdata = ACEfriction.DataUtils.load_h5fdata( \"./test/test-data-100.h5\"); \n# Specify size of training and test data\nn_train = Int(ceil(.8 * length(rdata)))\nn_test = length(rdata) - n_train\n# Partition data into train and test set and convert the data \nfdata = Dict(\"train\" => FrictionData.(rdata[1:n_train]), \n            \"test\"=> FrictionData.(rdata[n_train+1:end]));","category":"page"},{"location":"fitting-eft/#Specify-the-Friction-Model","page":"Fitting an Electronic Friction Tensor","title":"Specify the Friction Model","text":"","category":"section"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"Next, we specify the matrix models that will make up our friction model. In this case we only specify the single matrix model m_equ, which being of the type RWCMatrixModel is based on a row-wise coupling. ","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"property = EuclideanMatrix()\nspecies_friction = [:H]\nspecies_env = [:Cu]\nm_equ = RWCMatrixModel(property, species_friction, species_env;\n    species_substrat = [:Cu],\n    rcut = 5.0, \n    maxorder = 2, \n    maxdeg = 5,\n);","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"The first argument, property, of the constructor, RWCMatrixModel, specifies the equivariance symmetry of blocks. Here, property is of type EuclideanMatrix specifying each block to  transform like an Euclidean Matrix. In this modeling application, only hydrogen atoms feel friction, which we specify by setting the second argument species_friction to [:H]. Yet, the friction felt by an hydrogen atom is affected by the presence of both hydrogen atoms and copper atoms in its vicinty, which we specify by setting species_env to [:H, :Cu]. Furthermore, the physics is such that hydrogen models only feel friction if they are in contact with the metal surface. We specify this by setting species_substrat = [:Cu]. For further details and information on the remaining optional arguments see the docomentation of the constructor of RWCMatrixModel.","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"Next we build a friction model from the matrix model(s),","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"fm= FrictionModel((mequ=m_equ,)); #fm= FrictionModel((cov=m_cov,equ=m_equ));","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"Here, the mequ serves as the \"ID\" of the friction model m_equ within the friction model. The function get_ids returns the model IDs Wof all matrix model makig up a friction model, i.e.,","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"model_ids = get_ids(fm)","category":"page"},{"location":"fitting-eft/#Set-up-the-Training-Pipeline","page":"Fitting an Electronic Friction Tensor","title":"Set up the Training Pipeline","text":"","category":"section"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"To train our model we first extract the parameters from the friction model, which we use to initialize a structure of type FluxFrictionModel, which serves as a wrapper for the parameters","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"c=params(fm)                                \nffm = FluxFrictionModel(c)","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"Next, the function flux_assemble is used to prepare data for training. This includes evaluating the ACE-basis functions of the matrix models in fm on all configurations in the data set. Since the loss function of our model is quartic polynomial in the parameters, we don't need to reevaluate the ACE-basis functions at later stages of the training process.","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"flux_data = Dict( \"train\"=> flux_assemble(fdata[\"train\"], fm, ffm; ),\n                  \"test\"=> flux_assemble(fdata[\"test\"], fm, ffm));","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"Before starting the training we randomize the parameter values of our model and, if CUDA is available on our device, transform parameters to CUDA compatible cuarrays.","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"set_params!(ffm; sigma=1E-8)\n\nusing CUDA\ncuda = CUDA.functional()\n\nif cuda\n    ffm = fmap(cu, ffm)\nend","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"Finally, we set up the optimizer and data loader, and import the loss functions weighted_l2_loss, which evaluates the training and test loss as","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"mathcalL(c) =  Gamma_rm true - W odot Gamma_rm fit(c) _2^2","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"where odot is the entry-wise Hademard product, and W is a weight matrix assembled during the call of flux_assemble.","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"opt = Flux.setup(Adam(1E-3, (0.99, 0.999)),ffm)\ndloader = cuda ? DataLoader(flux_data[\"train\"] |> gpu, batchsize=10, shuffle=true) : DataLoader(flux_data[\"train\"], batchsize=10, shuffle=true)\nusing ACEfriction.FrictionFit: weighted_l2_loss","category":"page"},{"location":"fitting-eft/#Running-the-Optimizer","page":"Fitting an Electronic Friction Tensor","title":"Running the Optimizer","text":"","category":"section"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"Then, we train the model taking 200 passes through the training data: ","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"loss_traj = Dict(\"train\"=>Float64[], \"test\" => Float64[])\nepoch = 0\nnepochs = 100\nfor _ in 1:nepochs\n    epoch+=1\n    @time for d in dloader\n        ∂L∂m = Flux.gradient(weighted_l2_loss,ffm, d)[1]\n        Flux.update!(opt,ffm, ∂L∂m)       # method for \"explicit\" gradient\n    end\n    for tt in [\"test\",\"train\"]\n        push!(loss_traj[tt], weighted_l2_loss(ffm,flux_data[tt]))\n    end\n    println(\"Epoch: $epoch, Abs avg Training Loss: $(loss_traj[\"train\"][end]/n_train)), Test Loss: $(loss_traj[\"test\"][end]/n_test))\")\nend\nprintln(\"Epoch: $epoch, Abs Training Loss: $(loss_traj[\"train\"][end]), Test Loss: $(loss_traj[\"test\"][end])\")\nprintln(\"Epoch: $epoch, Avg Training Loss: $(loss_traj[\"train\"][end]/n_train), Test Loss: $(loss_traj[\"test\"][end]/n_test)\")","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"Once the training is complete we can extract the updated parameters from the wrapper ffm to parametrize the friction model. ","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"c = params(ffm)\nset_params!(fm, c)","category":"page"},{"location":"fitting-eft/#Evaluating-the-Friction-Model","page":"Fitting an Electronic Friction Tensor","title":"Evaluating the Friction Model","text":"","category":"section"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"The trained friction model can be used to evaluate the friction tensor bm Gamma and diffusion coeccifient matrix bm Sigma at configurations as follows ","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"at = fdata[\"test\"][1].atoms # extract atomic configuration from the test set\nGamma(fm, at) # evaluate the friction tensor\nΣ = Sigma(fm, at) # evaluate the diffusion coeffcient matrix","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"To simulate a Langevin equation, typically, both the friction coefficient and the diffusion coefficient matrix must be evaluated. Instead of evaluating them seperately it is more efficient to first evaluate the diffusion coefficient matrix and then evaluate the friction tensor from the the pre-computed diffusion coefficient matrix:","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"Σ = Sigma(fm, at) # evaluate the diffusion coeffcient matrix\nGamma(fm, Σ) # compute the friction tensor from the pre-computeed diffusion coefficient matrix.","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"The diffusion coefficient matrix Sigma can also be used to efficiently generate Gaussian pseudo random numbers rm Normal(0bf Gamma) as ","category":"page"},{"location":"fitting-eft/","page":"Fitting an Electronic Friction Tensor","title":"Fitting an Electronic Friction Tensor","text":"R = randf(fm,Σ)","category":"page"},{"location":"overview/#Model-Overview","page":"Overview","title":"Model Overview","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"The package ACEfriction provides an ACE-based implementation of the size-transferrable, E(3)-equivariant models introduced in Sachs et al., (2024) for configuration-dependent friction or diffusion tensors.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"In a nutshell, the package provides utilities to efficiently learn and evaluate E(3)-equivariant symmetric positive semi-definite matrix functions of the form","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"bm Gamma left ( (bm r_iz_i)_i=1^N_rm at right ) in mathbbR^3 N_rm at times 3N_rm at","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"where the bm r_is are the positions and the z_is are the atomic element types of atoms in an atomic configuration comprised of N_rm at atoms.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The underlying model is based on an equivariance-preserving matrix square root decomposition,","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"bm Gamma = bm Sigmabm Sigma^T","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"where block entries of the matrix square root bm Sigmaleft ( (bm r_iz_i)_i=1^N_rm at right ) in mathbbR^3 N_rm at times m with some m in mathbbN, are linearly expanded using an equivariant linear atomic cluster expansion.","category":"page"},{"location":"overview/#Code-Overview","page":"Overview","title":"Code Overview","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"The package ACEfriction is comprised of three main sub-modules:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The sub-module FrictionModels implements the structure FrictionModel, which facilitates the specification of and evaluation of friction models. The module implements the functions Gamma(fm::FrictionModel, at::Atoms), Sigma(fm::FrictionModel, at::Atoms) which evaluate the friction model fm at the atomic configuration at to the correspong friction tensor bm Gamma and  diffusion coefficient matrix bm Sigma, respectively. Moreover, it provides the functions Gamma(fm::FrictionModel, Σ), randf(fm::FrictionModel, Σ) for efficient computation of the friction tensor and generation of rm Normal(bm 0 bm Gamma)-distributed Gaussian random numbers from a precomputed diffusion coeffiient matrix Σ.\nThe sub-module MatrixModels implements various matrix models, which make up a friction model and, in essence, specify (i) properties of the ACE-basis used to evaluate blocks bm Sigma_ij of the difffusion matrix, and (ii) how blocks  bm Sigma_ij are combined in the assembly of the friction tensor bm Gamma. The assembly of the friction tensor is governed by what is referred to in Sachs et al., (2024) as the coupling scheme and implements versions of the the pair-wise coupling and row-wise coupling described therein.\nThe sub-module FrictionFit provides utility functions for training of friction models using the julia machine learning library Flux.jl. ","category":"page"},{"location":"overview/#Prototypical-Applications","page":"Overview","title":"Prototypical Applications","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Learned models of bm Gamma (and the corresponding matrix root bm Sigma) can be used to parametrize tensor-valued coefficients in an Itô diffusion process such as a configuration-dependent friction tensor in a kinetic Langevin equation,","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"beginaligned\ndotbm r = - M^-1bm p\ndotbm p = - nabla U(bm r) - bm Gamma(bm r)M^-1bm p + sqrt2 beta^-1 bm Sigma dotbm W\nendaligned","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"or a configuration-dependent diffusion tensor in an overdamped Langevin equation,","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"dotbm r = - bmGamma(bm r) nabla U(bm r)  + sqrt2 beta^-1 bmSigmacirc dotbm W + beta^-1rm div(bm Gamma(r))","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The model and code allows imposing additional symmetry constraints on the matrix bm Gamma. In particular, the learned friction-tensor bm Gamma can be specified to satisfy relevant symmetries for the dynamics (1) to be momentum-conserving, thus enabling learning and simulation of Multi-Body Dissipative Particle Dynamics (MD-DPD).","category":"page"},{"location":"installation/#Prerequisites","page":"Installation Guide","title":"Prerequisites","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"You will need to have Julia (v1.7 or newer) installed. The latest release and installation instruction for Julia are available here here.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"warning: Warning\nIf you are running Julia for the first time, there is a chance that the General Registrity is not added to you installation. To install the General Registry run the following code from within a Julia REPL.using Pkg\nPkg.Registry.add(\"General\")  ","category":"page"},{"location":"installation/#Installation","page":"Installation Guide","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"The package ACEfriction and some required dependencies can be downloaded from ACEregistry. To add this registry and install ACEfriction execute the following steps from within a Julia REPL. ","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Add the ACEregistry registry:\nusing Pkg\nPkg.Registry.add(RegistrySpec(url=\"https://github.com/ACEsuit/ACEregistry\"))\nInstall ACEfriction:\nPkg.add(\"ACEfriction\")","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Done! Now you can use the functionality of ACEfriction in your project by running using ACEfriction.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"note: Note\nIt is recommended to install ACEfriction within a dedicated julia environment, where approriate version bounds can be set within the Project.toml file, and versions of dependencies are tracked in a Manifest.toml file. To create a new project, simply create a new directory, navigate to that directory and runPkg.activate(\".\")Then, execute sthe teps 1. and 2. from within the project directory. ","category":"page"},{"location":"function-manual/#Function-Manual-(@id-Function-Manual)","page":"Function Manual (@id Function-Manual)","title":"Function Manual (@id Function-Manual)","text":"","category":"section"},{"location":"function-manual/#ACEfriction.FrictionModels.jl","page":"Function Manual (@id Function-Manual)","title":"ACEfriction.FrictionModels.jl","text":"","category":"section"},{"location":"function-manual/","page":"Function Manual (@id Function-Manual)","title":"Function Manual (@id Function-Manual)","text":"CurrentModule = ACEfriction.FrictionModels","category":"page"},{"location":"function-manual/","page":"Function Manual (@id Function-Manual)","title":"Function Manual (@id Function-Manual)","text":"A friction model is a wrapper around a named tuple of matrix models, i.e. ","category":"page"},{"location":"function-manual/","page":"Function Manual (@id Function-Manual)","title":"Function Manual (@id Function-Manual)","text":"struct FrictionModel{MODEL_IDS} <: AbstractFrictionModel\n    matrixmodels::NamedTuple{MODEL_IDS} \nend","category":"page"},{"location":"function-manual/","page":"Function Manual (@id Function-Manual)","title":"Function Manual (@id Function-Manual)","text":"The symbols contained in the tuple MODEL_IDS are referred to as \"IDs\" of the corresponding matrix models. When evaluated at an atomic configuration, the resulting friction tensor is the sum of the friction tensors of all matrix models in the friction model, whereas diffusion coefficient matrices are evaluated seperately for each matrix model and returned in the form of a named tuple of the same signature. The following functions act on structures of type FrictionModel: ","category":"page"},{"location":"function-manual/","page":"Function Manual (@id Function-Manual)","title":"Function Manual (@id Function-Manual)","text":"Gamma","category":"page"},{"location":"function-manual/#ACEfriction.FrictionModels.Gamma","page":"Function Manual (@id Function-Manual)","title":"ACEfriction.FrictionModels.Gamma","text":"Gamma(fm::FrictionModel, at::Atoms; filter=(_,_)->true, T=Float64)\n\nEvaluates the friction tensor according to the friction model fm at the atomic configuration at::Atoms. The friction tensor is the sum of the friction tensors of all matrix models in fm.matrixmodels.\n\nArguments:\n\nfm – the friction model of which the friction tensor is evaluated.\nat – the atomic configuration at which the basis is evaluated\nfilter  – (optional, default: (_,_)->true) a filter function of the generic form (i::Int,at::Atoms) -> Bool. Only atoms at[i] for which filter(i,at) returns true are included in the evaluation of the friction tensor.  \n\nOutput:\n\nA friction tensor in the form of a sparse 3N x 3N matrix, where N is the number of atoms in the atomic configuration at.  \n\n\n\n\n\nGamma(fm::FrictionModel{MODEL_IDS}, Σ_vec::NamedTuple{MODEL_IDS}) where {MODEL_IDS}\n\nComputes the friction tensor from a pre-computed collection of diffusion coefficient matrices.  The friction tensor is the sum of the squares of all diffusion coefficient matrices in the collection.\n\nArguments:\n\nfm – the friction model of which the friction tensor is evaluated. The friction tensor is the sum of the friction tensors of all matrix models in fm.matrixmodels.\nΣ – a collection of diffusion coefficient matrices. The friction tensor is the sum of the squares of all matrices in Σ.\n\nOutput:\n\nA friction tensor in the form of a sparse 3N x 3N matrix, where N is the number of atoms in the atomic configuration at.  The friction tensor is the sum of the symmetric squares SigmaSigma^T of all diffusion coefficient matrices Sigma in Σ_vec.\n\n\n\n\n\n","category":"function"},{"location":"function-manual/","page":"Function Manual (@id Function-Manual)","title":"Function Manual (@id Function-Manual)","text":"Sigma","category":"page"},{"location":"function-manual/#ACEfriction.FrictionModels.Sigma","page":"Function Manual (@id Function-Manual)","title":"ACEfriction.FrictionModels.Sigma","text":"Sigma(fm::FrictionModel{MODEL_IDS}, at::Atoms; filter=(_,_)->true, T=Float64) where {MODEL_IDS}\n\nComputes the diffusion coefficient matrices for all matrix models in the friction model at a given configuration.\n\nArguments:\n\nfm – the friction model of which the diffusion coefficient matrices are evaluated\nat – the atomic configuration at which the diffusion coefficient matrices are evaluated\nfilter  – (optional, default: (_,_)->true) a filter function of the generic form (i::Int,at::Atoms) -> Bool. Only atoms at[i] for which filter(i,at) returns true are included in the evaluation of the diffusion coefficient matrices.\n\nOutput:\n\nA NamedTuple of diffusion coefficient matrices, where the keys are the IDs of the matrix models in the friction model.\n\n\n\n\n\n","category":"function"},{"location":"function-manual/","page":"Function Manual (@id Function-Manual)","title":"Function Manual (@id Function-Manual)","text":"randf","category":"page"},{"location":"function-manual/#ACEfriction.MatrixModels.randf","page":"Function Manual (@id Function-Manual)","title":"ACEfriction.MatrixModels.randf","text":"randf(fm::FrictionModel{MODEL_IDS}, Σ::NamedTuple{MODEL_IDS}) where {MODEL_IDS}\n\nGenerates a rm Normal(bm 0 bm Gamma)-distributed Gaussian pseudo random number from a precomputed diffusion coeffiient matrices.\n\nArguments:\n\nfm – the friction model of which the friction tensor is evaluated. The friction tensor is the sum of the friction tensors of all matrix models in fm.matrixmodels.\nΣ – a collection of diffusion coefficient matrices. The friction tensor is the sum of the squares of all matrices in Σ.\n\nOutput:\n\nA rm Normal(bm 0 bm Gamma)-distributed Gaussian vector R::Vector{3,Float64} of length N, where N is the number of atoms in the configuration for which Σ was evaluated.\n\n\n\n\n\n","category":"function"},{"location":"function-manual/","page":"Function Manual (@id Function-Manual)","title":"Function Manual (@id Function-Manual)","text":"basis","category":"page"},{"location":"function-manual/#ACEfriction.MatrixModels.basis","page":"Function Manual (@id Function-Manual)","title":"ACEfriction.MatrixModels.basis","text":"basis(fm::FrictionModel{MODEL_IDS}, at::Atoms; join_sites=false, filter=(_,_)->true, T=Float64) where {MODEL_IDS}\n\nEvaluates the ACE-basis functions of the friction model fm at the atomic configuration at::Atoms.\n\nArguments:\n\nfm – the friction model of which the basis is evaluated\nat – the atomic configuration at which the basis is evaluated\njoin_sites – (optional, default: false) if true, the basis evaulations of all matrix models are concatenated into a single array. If false, the basis evaluations are returned as a named tuple of the type NamedTuple{MODEL_IDS}.\nfilter  – (optional, default: (_,_)->true) a filter function of the generic form (i::Int,at::Atoms) -> Bool. The atom at[i] will be included in the basis iff filter(i,at) returns true.  \n\n\n\n\n\n","category":"function"},{"location":"function-manual/#Setter-and-getter-functions-for-model-parameters","page":"Function Manual (@id Function-Manual)","title":"Setter and getter functions for model parameters","text":"","category":"section"},{"location":"function-manual/","page":"Function Manual (@id Function-Manual)","title":"Function Manual (@id Function-Manual)","text":"params","category":"page"},{"location":"function-manual/#ACE.params","page":"Function Manual (@id Function-Manual)","title":"ACE.params","text":"params(fm::FrictionModel{MODEL_IDS}) where {MODEL_IDS}\n\nReturns the parameters of all matrix models in the FrictionModel object as a NamedTuple.\n\n\n\n\n\n","category":"function"},{"location":"function-manual/","page":"Function Manual (@id Function-Manual)","title":"Function Manual (@id Function-Manual)","text":"nparams","category":"page"},{"location":"function-manual/#ACE.nparams","page":"Function Manual (@id Function-Manual)","title":"ACE.nparams","text":"nparams(fm::FrictionModel{MODEL_IDS}) where {MODEL_IDS}\n\nReturns the total number of scalar parameters of all matrix models in the FrictionModel object.\n\n\n\n\n\n","category":"function"},{"location":"function-manual/","page":"Function Manual (@id Function-Manual)","title":"Function Manual (@id Function-Manual)","text":"set_params!","category":"page"},{"location":"function-manual/#ACE.set_params!","page":"Function Manual (@id Function-Manual)","title":"ACE.set_params!","text":"set_params!(fm::FrictionModel, θ::NamedTuple)\n\nSets the parameters of all matrix models in the FrictionModel object whose ID is contained in θ::NamedTuple to the values specified therein.\n\n\n\n\n\n","category":"function"},{"location":"function-manual/","page":"Function Manual (@id Function-Manual)","title":"Function Manual (@id Function-Manual)","text":"set_zero!","category":"page"},{"location":"function-manual/#ACEfriction.MatrixModels.set_zero!","page":"Function Manual (@id Function-Manual)","title":"ACEfriction.MatrixModels.set_zero!","text":"set_zero!(fm::FrictionModel, model_ids)\n\nSets the parameters of all matrix models in the FrictionModel object to zero.\n\n\n\n\n\n","category":"function"},{"location":"function-manual/#ACEfriction.MatrixModels.jl","page":"Function Manual (@id Function-Manual)","title":"ACEfriction.MatrixModels.jl","text":"","category":"section"},{"location":"function-manual/#ACEfriction.FrictionFit.jl","page":"Function Manual (@id Function-Manual)","title":"ACEfriction.FrictionFit.jl","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The julia package ACEfriction.jl facilitates simulation and machine learning of configuration-dependent friction tensor models from data. The models are based on an equivariant Atomic Cluster Expansion (ACE) and, as such, are computationally highly efficient and size transferable. The underlying framework of model construction is described in detail in Sachs et al., (2024).  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"For a quick start, we recommend reading the Installation Instructions and the Overview section, followed by the Workflow Examples. Detailed documentation of front-end-facing functions can be found in the Function Manual.  ","category":"page"},{"location":"#ACEfriction-paper","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you are using ACEfriction.jl in your work, please cite the following article: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Sachs, M., Stark, W. G., Maurer, R. J., & Ortner, C. (2024). Equivariant Representation of Configuration-Dependent Friction Tensors in Langevin Heatbaths. [arxiv]","category":"page"}]
}
